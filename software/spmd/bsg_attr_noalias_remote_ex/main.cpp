// This kernel performs saxpy to demonstrate how the placement of
// bsg_attr_remote AND bsg_attr_noalias affects code generation.

// For a demonstration of each annotation independently see the
// remote, and noalias directories.

// NOTE: 

// bsg_attr_remote is currently NOT SUPPORTED in C++ WITH GCC. This
// file is written in C to demonstrate concepts until a solution is
// developed.


// Our goal is to optimize saxpy (Scalar * X Plus Y) by unrolling it
// by a factor of 4 to increase performance. Performance gains can be
// attributed to two effects: 

// 1) Increasing the distance between load and use instructions to
// hide DRAM latency, by informing the compiler about the latency of
// (remote) loads

// 2) Reducing loop control overhead.

// In this set of examples we will use the bsg_attr_remote annotation 
// Our goal is to optimize vector add, and unroll it by a factor of 4
// to improve performance by 1) Issuing blocks of loads to hide latency
// 2) Reduce loop control overhead.

// Simply unrolling the loop will not achieve either 1) or 2)
// above. The compiler is not allowed to reorder loads and stores
// unless it can absolutely determine that the loads and stores are
// independent -- i.e. they do not alias. Furthermore, it will not
// have accurate latency estimates for load/store instructions.

// To solve the aliasing issue, use bsg_attr_remote.In general the
// compiler cannot infer alias information from pointers just by
// analyzing the code. The annotation bsg_attr_noalias is required and
// is similar to the behavior of __restrict.

// Even if the code is decorated with bsg_attr_noalias, the code will
// still may not be optimal. GCC assumes a normal processor hierarchy
// with a 1-2 cycle L1 cache. This means that load instructions will
// be quickly followed by dependent instructions, and dependent
// instructions will be quickly followed by subsequent dependent
// instructions, such as store. This works for data in scratchpad, but
// when data is located in DRAM, or cache, the processor will stall on
// dependent instructions will the data is in flight because the
// compiler did not reorder instructions to hide data access
// latency. Therefore, is critical to give the compiler accurate
// information about the expected latency to access data.

// To signal that a memory location has high latency, annotate
// pointers with bsg_attr_remote.


// The C implementation of saxpy is in saxpy-c.c
// The C++ implementation of saxpy is in saxpy-cpp.cpp

// These sources are compiled independently from each other, and
// main.c. They are linked together to form main.riscv. In this way we
// can demonstrate/test the differences in C/C++.

#include <bsg_manycore.h>
#include <bsg_set_tile_x_y.h>
// saxpy.h is generated by saxpy.py. It defines MACRO_A, MACRO_B, MACRO_GOLD, and N_ELS
#include "saxpy.h"
// saxpy-c.h and saxy-cpp.hpp contain the C and C++ function
// definitions, respectively.
#include "saxpy-c.h"
#include "saxpy-cpp.hpp"
#include <string.h>

#define SAXPY_TAG_BASE 0
#define SAXPY_TAG_C 1
#define SAXPY_TAG_C_MOREUNROLL 2
#define SAXPY_TAG_CPP 3
#define SAXPY_TAG_CPP_MOREUNROLL 4

extern "C"
void saxpy(float  *A, float  *B, float *C, float alpha) {
        float s = 0;
        for(int i = 0;  i < N_ELS; ++i) {
                C[i] = alpha * A[i] + B[i];
        }
}

// Same implementation as above, except with bsg_attr_remote to
// satisfy LLVM type checking.
void _saxpy(float  bsg_attr_remote *A, float  bsg_attr_remote *B, float bsg_attr_remote *C, float alpha) {
        float s = 0;
        for(int i = 0;  i < N_ELS; ++i) {
                C[i] = alpha * A[i] + B[i];
        }
}

float A[N_ELS] __attribute__ ((section (".dram"))) = MACRO_A;
float B[N_ELS] __attribute__ ((section (".dram"))) = MACRO_B;
float C[N_ELS] __attribute__ ((section (".dram"))) = {0};
float gold[N_ELS] __attribute__ ((section (".dram")));

// Variables and functions with an underscore indicate bsg_attr_remote
// has been applied and are necessary to pass LLVM type checking.
float bsg_attr_remote _A[N_ELS] __attribute__ ((section (".dram"))) = MACRO_A;
float bsg_attr_remote _B[N_ELS] __attribute__ ((section (".dram"))) = MACRO_B;
float bsg_attr_remote _C[N_ELS] __attribute__ ((section (".dram"))) = {0};
float bsg_attr_remote _gold[N_ELS] __attribute__ ((section (".dram"))) = {0};

int main(){

        bsg_set_tile_x_y();

        if ((__bsg_x == 0) && (__bsg_y == 0)) {
                // Produce "gold" (known good) outputs of the SAXPY
                // function. 
                saxpy(A, B, gold, MACRO_ALPHA); 
                _saxpy(_A, _B, _gold, MACRO_ALPHA); 
 
                // **************************************************
                // Test the simple version of SAXPY
                // **************************************************
                bsg_printf("Testing SAXPY\n");
                // Heat the cache (just for demonstration purposes)
                saxpy(A, B, C, MACRO_ALPHA);
                // Measure performance
                bsg_cuda_print_stat_start(SAXPY_TAG_BASE);
                saxpy(A, B, C, MACRO_ALPHA);
                bsg_cuda_print_stat_end(SAXPY_TAG_BASE);
                
                if (memcmp(C, gold, N_ELS * sizeof(*C)))
                        bsg_fail();
                memset(C, 0, N_ELS * sizeof(*C));


                // **************************************************
                // Test the C version of SAXPY
                // **************************************************
                bsg_printf("Testing C SAXPY +unroll +noalias + remote\n");
                // Heat the cache (just for demonstration purposes)
                saxpy_c(_A, _B, _C, MACRO_ALPHA);
                // Measure performance
                bsg_cuda_print_stat_start(SAXPY_TAG_C);
                saxpy_c(_A, _B, _C, MACRO_ALPHA);
                bsg_cuda_print_stat_end(SAXPY_TAG_C);
                
#ifndef __llvm__
                // LLVM complains about memory intrinsics...
                if (memcmp(_C, _gold, N_ELS * sizeof(*C)))
                        bsg_fail();
                memset(_C, 0, N_ELS * sizeof(*C));
#endif

                // **************************************************
                // Test the C version of SAXPY (with more unrolling)
                // **************************************************
                bsg_printf("Testing C SAXPY (MORE) +unroll +noalias + remote\n");
                // Heat the cache (just for demonstration purposes)
                saxpy_c_moreunroll(_A, _B, _C, MACRO_ALPHA);
                // Measure performance
                bsg_cuda_print_stat_start(SAXPY_TAG_C_MOREUNROLL);
                saxpy_c(_A, _B, _C, MACRO_ALPHA);
                bsg_cuda_print_stat_end(SAXPY_TAG_C_MOREUNROLL);
                
#ifndef __llvm__
                // LLVM complains about memory intrinsics...
                if (memcmp(_C, _gold, N_ELS * sizeof(*C)))
                        bsg_fail();
                memset(_C, 0, N_ELS * sizeof(*C));
#endif

                // **************************************************
                // Test the CPP version of SAXPY
                // **************************************************
                bsg_printf("Testing CPP SAXPY +unroll +noalias +remote\n");
                // Heat the cache (just for demonstration purposes)
                saxpy_cpp(_A, _B, _C, MACRO_ALPHA);
                // Measure performance
                bsg_cuda_print_stat_start(SAXPY_TAG_CPP);
                saxpy_cpp(_A, _B, _C, MACRO_ALPHA);
                bsg_cuda_print_stat_end(SAXPY_TAG_CPP);
                
#ifndef __llvm__
                // LLVM complains about memory intrinsics...
                if (std::memcmp(_C, _gold, N_ELS * sizeof(*C)))
                        bsg_fail();
                memset(_C, 0, N_ELS * sizeof(*C));
#endif

                // **************************************************
                // Test the CPP version of SAXPY (with more unrolling)
                // **************************************************
                bsg_printf("Testing C SAXPY (MORE) +unroll +noalias + remote\n");
                // Heat the cache (just for demonstration purposes)
                saxpy_cpp_moreunroll(_A, _B, _C, MACRO_ALPHA);
                // Measure performance
                bsg_cuda_print_stat_start(SAXPY_TAG_CPP_MOREUNROLL);
                saxpy_c(_A, _B, _C, MACRO_ALPHA);
                bsg_cuda_print_stat_end(SAXPY_TAG_CPP_MOREUNROLL);
                
#ifndef __llvm__
                // LLVM complains about memory intrinsics...
                if (std::memcmp(_C, _gold, N_ELS * sizeof(*C)))
                        bsg_fail();
                memset(_C, 0, N_ELS * sizeof(*C));
#endif

                // Finally, Terminate cleanly
                bsg_finish();
        }

        bsg_wait_while(1);
}
