// This kernel performs saxpy to demonstrate how the placement of
// bsg_attr_noalias affects code generation.

// NOTE: 

// bsg_attr_noalias is NOT FULLY SUPPORTED IN LLVM. It works for 1D array
// accesses, but your mileage may vary with anything more complex.


// Our goal is to optimize saxpy (Scalar * X Plus Y) by unrolling it
// by a factor of 4 to increase performance. Performance gains can be
// attributed to two effects: 

// 1) Increasing the distance between load and use instructions to
// hide DRAM latency 

// 2) Reduce loop control overhead.

// In this example we will use the restrict type qualifier
// (https://en.cppreference.com/w/c/language/restrict) on pointers to
// indicate that unique pointer declarations represent non-overlapping
// regions of memory (i.e. they do not alias).

// restrict allows the compiler to reorder loads and stores to unique
// pointer declarations because stores to a restricted pointer do not
// modify the data of restricted pointer declarations.

// Reordering means loads can be moved ahead of the stores of a
// previous iteration to increase the instruction distance between
// load and use.

// Using bsg_attr_noalias is one of TWO critical steps to utilizing
// non-blocking loads effectively in the manycore architecture.

// For the second critical step see kernel.cpp in the remote
// directory.

// For a synthesis of the two, see remote+restrict



// The C implementation of saxpy is in saxpy-c.c
// The C++ implementation of saxpy is in saxpy-cpp.cpp

// These sources are compiled independently from each other, and
// main.c. They are linked together to form main.riscv. In this way we
// can demonstrate/test the differences in C/C++.

#include <bsg_manycore.h>
#include <bsg_set_tile_x_y.h>
// saxpy.h is generated by saxpy.py. It defines MACRO_A, MACRO_B, MACRO_GOLD, and N_ELS
#include "saxpy.h"
// saxpy-c.h and saxy-cpp.hpp contain the C and C++ function
// definitions, respectively.
#include "saxpy-c.h"
#include "saxpy-cpp.hpp"
#include <string.h>

#define SAXPY_TAG_BASE 0
#define SAXPY_TAG_C_UNROLL 1
#define SAXPY_TAG_C_UNROLL_CONST 2
#define SAXPY_TAG_C_UNROLL_NOALIAS 3
#define SAXPY_TAG_C_UNROLL_NOALIAS_NOALIAS 4
#define SAXPY_TAG_C_UNROLL_NOALIAS_FLAT 5
#define SAXPY_TAG_C_UNROLL_NOALIAS_INLINE 6
#define SAXPY_TAG_C_UNROLL_NOALIAS_CAST 7
#define SAXPY_TAG_CPP_UNROLL 8
#define SAXPY_TAG_CPP_UNROLL_CONST 9
#define SAXPY_TAG_CPP_UNROLL_NOALIAS 10
#define SAXPY_TAG_CPP_UNROLL_NOALIAS_NOALIAS 11
#define SAXPY_TAG_CPP_UNROLL_NOALIAS_FLAT 12
#define SAXPY_TAG_CPP_UNROLL_NOALIAS_INLINE 13
#define SAXPY_TAG_CPP_UNROLL_NOALIAS_CAST 14

extern "C"
void saxpy(float  *A, float  *B, float *C, float alpha) {
        float s = 0;
        for(int i = 0;  i < N_ELS; ++i) {
                C[i] = alpha * A[i] + B[i];
        }
}

float A[N_ELS] __attribute__ ((section (".dram"))) = MACRO_A;
float _A[2][N_ELS] __attribute__ ((section (".dram"))) = {MACRO_A, MACRO_B};
float **A2D = (float **)_A;
float *Ax2 = _A[0];
float B[N_ELS] __attribute__ ((section (".dram"))) = MACRO_B;
float C[N_ELS] __attribute__ ((section (".dram"))) = {0};
float gold[N_ELS] __attribute__ ((section (".dram")));

int main(){

        bsg_set_tile_x_y();

        if ((__bsg_x == 0) && (__bsg_y == 0)) {
                // Construct for later
                float *__A[2] = {_A[0], _A[1]};

                saxpy(A, B, gold, MACRO_ALPHA); 
 
                // **************************************************
                // Test the simple version of SAXPY
                // **************************************************
                bsg_printf("Testing SAXPY\n");
                // Heat the cache (just for demonstration purposes)
                saxpy(A, B, C, MACRO_ALPHA);
                // Measure performance
                bsg_cuda_print_stat_start(SAXPY_TAG_BASE);
                saxpy(A, B, C, MACRO_ALPHA);
                bsg_cuda_print_stat_end(SAXPY_TAG_BASE);
                
                if (memcmp(C, gold, N_ELS * sizeof(*C)))
                        bsg_fail();
                memset(C, 0, N_ELS * sizeof(*C));


                // **************************************************
                // Test the C version of SAXPY +unroll
                // **************************************************
                bsg_printf("Testing C SAXPY +unroll\n");
                // Heat the cache (just for demonstration purposes)
                saxpy_c(A, B, C, MACRO_ALPHA);
                // Measure performance
                bsg_cuda_print_stat_start(SAXPY_TAG_C_UNROLL);
                saxpy_c(A, B, C, MACRO_ALPHA);
                bsg_cuda_print_stat_end(SAXPY_TAG_C_UNROLL);
                
                if (memcmp(C, gold, N_ELS * sizeof(*C)))
                        bsg_fail();
                memset(C, 0, N_ELS * sizeof(*C));

                // **************************************************
                // Test the C version of SAXPY +unroll +const
                // THIS DEMONSTRATES THAT CONST DOES NOT SOLVE THE ALIASING PROBLEM
                // **************************************************
                bsg_printf("Testing C SAXPY +unroll +const\n");
                // Heat the cache (just for demonstration purposes)
                saxpy_c_const(A, B, C, MACRO_ALPHA);
                // Measure performance
                bsg_cuda_print_stat_start(SAXPY_TAG_C_UNROLL_CONST);
                saxpy_c_const(A, B, C, MACRO_ALPHA);
                bsg_cuda_print_stat_end(SAXPY_TAG_C_UNROLL_CONST);
                
                if (memcmp(C, gold, N_ELS * sizeof(*C)))
                        bsg_fail();
                memset(C, 0, N_ELS * sizeof(*C));

                // **************************************************
                // Test the C version of SAXPY +unroll +noalias
                // **************************************************
                bsg_printf("Testing C SAXPY +unroll +noalias\n");
                // Heat the cache (just for demonstration purposes)
                saxpy_c_noalias(A, B, C, MACRO_ALPHA);
                // Measure performance
                bsg_cuda_print_stat_start(SAXPY_TAG_C_UNROLL_NOALIAS);
                saxpy_c_noalias(A, B, C, MACRO_ALPHA);
                bsg_cuda_print_stat_end(SAXPY_TAG_C_UNROLL_NOALIAS);
                
                if (memcmp(C, gold, N_ELS * sizeof(*C)))
                        bsg_fail();
                memset(C, 0, N_ELS * sizeof(*C));

                // **************************************************
                // Test the C version of SAXPY +unroll +noalias (2-D A)
                // **************************************************
                bsg_printf("Testing C SAXPY +unroll +noalias on 2D A\n");
                // Heat the cache (just for demonstration purposes)
                saxpy_c_noalias_noalias(__A, C, MACRO_ALPHA);
                // Measure performance
                bsg_cuda_print_stat_start(SAXPY_TAG_C_UNROLL_NOALIAS_NOALIAS);
                saxpy_c_noalias_noalias(__A, C, MACRO_ALPHA);
                bsg_cuda_print_stat_end(SAXPY_TAG_C_UNROLL_NOALIAS_NOALIAS);
                
                if (memcmp(C, gold, N_ELS * sizeof(*C)))
                        bsg_fail();
                memset(C, 0, N_ELS * sizeof(*C));

                // **************************************************
                // Test the C version of SAXPY +unroll +noalias +flattened
                // **************************************************
                bsg_printf("Testing C SAXPY +unroll +noalias +flat (double-length A)\n");
                // Heat the cache (just for demonstration purposes)
                saxpy_c_noalias_flat(Ax2, C, MACRO_ALPHA);
                // Measure performance
                bsg_cuda_print_stat_start(SAXPY_TAG_C_UNROLL_NOALIAS_FLAT);
                saxpy_c_noalias_flat(Ax2, C, MACRO_ALPHA);
                bsg_cuda_print_stat_end(SAXPY_TAG_C_UNROLL_NOALIAS_FLAT);
                
                if (memcmp(C, gold, N_ELS * sizeof(*C)))
                        bsg_fail();
                memset(C, 0, N_ELS * sizeof(*C));

                // **************************************************
                // Test the C version of SAXPY +unroll +noalias +inline
                // **************************************************
                bsg_printf("Testing C SAXPY +unroll +noalias +inline (Inlining removes noalias)\n");
                // Heat the cache (just for demonstration purposes)
                saxpy_c_inline(A, B, C, MACRO_ALPHA);
                // Measure performance
                bsg_cuda_print_stat_start(SAXPY_TAG_C_UNROLL_NOALIAS_INLINE);
                saxpy_c_inline(A, B, C, MACRO_ALPHA);
                bsg_cuda_print_stat_end(SAXPY_TAG_C_UNROLL_NOALIAS_INLINE);
                
                if (memcmp(C, gold, N_ELS * sizeof(*C)))
                        bsg_fail();
                memset(C, 0, N_ELS * sizeof(*C));


                // **************************************************
                // Test the CPP version of SAXPY +unroll
                // **************************************************
                bsg_printf("Testing CPP SAXPY +unroll\n");
                // Heat the cache (just for demonstration purposes)
                saxpy_cpp(A, B, C, MACRO_ALPHA);
                // Measure performance
                bsg_cuda_print_stat_start(SAXPY_TAG_CPP_UNROLL);
                saxpy_cpp(A, B, C, MACRO_ALPHA);
                bsg_cuda_print_stat_end(SAXPY_TAG_CPP_UNROLL);
                
                if (memcmp(C, gold, N_ELS * sizeof(*C)))
                        bsg_fail();
                memset(C, 0, N_ELS * sizeof(*C));

                // **************************************************
                // Test the CPP version of SAXPY +unroll +const
                // THIS DEMONSTRATES THAT CONST DOES NOT SOLVE THE ALIASING PROBLEM
                // **************************************************
                bsg_printf("Testing CPP SAXPY +unroll +const\n");
                // Heat the cache (just for demonstration purposes)
                saxpy_cpp_const(A, B, C, MACRO_ALPHA);
                // Measure performance
                bsg_cuda_print_stat_start(SAXPY_TAG_CPP_UNROLL_CONST);
                saxpy_cpp_const(A, B, C, MACRO_ALPHA);
                bsg_cuda_print_stat_end(SAXPY_TAG_CPP_UNROLL_CONST);
                
                if (memcmp(C, gold, N_ELS * sizeof(*C)))
                        bsg_fail();
                memset(C, 0, N_ELS * sizeof(*C));

                // **************************************************
                // Test the CPP version of SAXPY +unroll +noalias
                // **************************************************
                bsg_printf("Testing CPP SAXPY +unroll +noalias\n");
                // Heat the cache (just for demonstration purposes)
                saxpy_cpp_noalias(A, B, C, MACRO_ALPHA);
                // Measure performance
                bsg_cuda_print_stat_start(SAXPY_TAG_CPP_UNROLL_NOALIAS);
                saxpy_cpp_noalias(A, B, C, MACRO_ALPHA);
                bsg_cuda_print_stat_end(SAXPY_TAG_CPP_UNROLL_NOALIAS);
                
                if (memcmp(C, gold, N_ELS * sizeof(*C)))
                        bsg_fail();
                memset(C, 0, N_ELS * sizeof(*C));

                // **************************************************
                // Test the CPP version of SAXPY +unroll +noalias (2-D A)
                // **************************************************
                bsg_printf("Testing CPP SAXPY +unroll +noalias on 2D A\n");
                // Heat the cache (just for demonstration purposes)
                saxpy_cpp_noalias_noalias(__A, C, MACRO_ALPHA);
                // Measure performance
                bsg_cuda_print_stat_start(SAXPY_TAG_CPP_UNROLL_NOALIAS_NOALIAS);
                saxpy_cpp_noalias_noalias(__A, C, MACRO_ALPHA);
                bsg_cuda_print_stat_end(SAXPY_TAG_CPP_UNROLL_NOALIAS_NOALIAS);
                
                if (memcmp(C, gold, N_ELS * sizeof(*C)))
                        bsg_fail();
                memset(C, 0, N_ELS * sizeof(*C));

                // **************************************************
                // Test the CPP version of SAXPY +unroll +noalias +flattened
                // **************************************************
                bsg_printf("Testing CPP SAXPY +unroll +noalias +flat (double-length A)\n");
                // Heat the cache (just for demonstration purposes)
                saxpy_cpp_noalias_flat(Ax2, C, MACRO_ALPHA);
                // Measure performance
                bsg_cuda_print_stat_start(SAXPY_TAG_CPP_UNROLL_NOALIAS_FLAT);
                saxpy_cpp_noalias_flat(Ax2, C, MACRO_ALPHA);
                bsg_cuda_print_stat_end(SAXPY_TAG_CPP_UNROLL_NOALIAS_FLAT);
                
                if (memcmp(C, gold, N_ELS * sizeof(*C)))
                        bsg_fail();
                memset(C, 0, N_ELS * sizeof(*C));

                // **************************************************
                // Test the CPP version of SAXPY +unroll +noalias +inline
                // **************************************************
                bsg_printf("Testing CPP SAXPY +unroll +noalias +inline (Inlining removes noalias)\n");
                // Heat the cache (just for demonstration purposes)
                saxpy_cpp_inline(A, B, C, MACRO_ALPHA);
                // Measure performance
                bsg_cuda_print_stat_start(SAXPY_TAG_CPP_UNROLL_NOALIAS_INLINE);
                saxpy_cpp_inline(A, B, C, MACRO_ALPHA);
                bsg_cuda_print_stat_end(SAXPY_TAG_CPP_UNROLL_NOALIAS_INLINE);
                
                if (memcmp(C, gold, N_ELS * sizeof(*C)))
                        bsg_fail();
                memset(C, 0, N_ELS * sizeof(*C));

                // **************************************************
                // Test the CPP version of SAXPY +unroll +noalias +2D-cast
                // **************************************************
                bsg_printf("Testing CPP SAXPY +unroll +noalias +2D-cast (Casting from 1-D to 2-D array)\n");
                // Heat the cache (just for demonstration purposes)
                saxpy_cpp_cast(Ax2, C, MACRO_ALPHA);
                // Measure performance
                bsg_cuda_print_stat_start(SAXPY_TAG_CPP_UNROLL_NOALIAS_CAST);
                saxpy_cpp_cast(Ax2, C, MACRO_ALPHA);
                bsg_cuda_print_stat_end(SAXPY_TAG_CPP_UNROLL_NOALIAS_CAST);
                
                if (memcmp(C, gold, N_ELS * sizeof(*C)))
                        bsg_fail();
                memset(C, 0, N_ELS * sizeof(*C));

                // Finally, Terminate cleanly
                bsg_finish();
        }

        bsg_wait_while(1);
}
