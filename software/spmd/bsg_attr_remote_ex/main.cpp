// This program performs saxpy to demonstrate how the placement of
// bsg_attr_remote affects code generation.

// NOTE: bsg_attr_remote is has no effect in C++ with GCC.



// Our goal is to optimize saxpy (Scalar * X Plus Y) by unrolling it
// by a factor of 4 to increase performance. Performance gains can be
// attributed to two effects: 

// 1) Increasing the distance between load and use instructions to
// hide DRAM latency, by informing the compiler about the latency of
// (remote) loads

// 2) Reduce loop control overhead.

// In this set of examples we will use the bsg_attr_remote annotation 
// Our goal is to optimize vector add, and unroll it by a factor of 4
// to improve performance by 1) Issuing blocks of loads to hide latency
// 2) Reduce loop control overhead.

// Using bsg_attr_remote is one of TWO critical steps to utilizing
// non-blocking loads effectively in the manycore architecture.

// For the other critical step see main..cpp in the restrict
// directory. 

// For a synthesis of the two, see remote+restrict



// The C implementation of saxpy is in saxpy-c.c
// The C++ implementation of saxpy is in saxpy-cpp.cpp

// These sources are compiled independently from each other, and
// main.c. They are linked together to form main.riscv. In this way we
// can demonstrate/test the differences in C/C++.

#include <bsg_manycore.h>
#include <bsg_set_tile_x_y.h>
// saxpy.h is generated by saxpy.py. It defines MACRO_A, MACRO_B, MACRO_GOLD, and N_ELS
#include "saxpy.h"
// saxpy-c.h and saxy-cpp.hpp contain the C and C++ function
// definitions, respectively.
#include "saxpy-c.h"
#include "saxpy-cpp.hpp"
#include <string.h>

#define SAXPY_TAG_BASE 0
#define SAXPY_TAG_BASE 0
#define SAXPY_TAG_C_UNROLL 1
#define SAXPY_TAG_C_UNROLL 1
#define SAXPY_TAG_C_UNROLL_REMOTE 2
#define SAXPY_TAG_C_UNROLL_REMOTE 2
#define SAXPY_TAG_CPP_UNROLL 3
#define SAXPY_TAG_CPP_UNROLL 3
#define SAXPY_TAG_CPP_UNROLL_REMOTE 4
#define SAXPY_TAG_CPP_UNROLL_REMOTE 4

extern "C"
void saxpy(float  *A, float  *B, float *C, float alpha) {
        float s = 0;
        for(int i = 0;  i < N_ELS; ++i) {
                C[i] = alpha * A[i] + B[i];
        }
}


// Please please please ignore this. We have to declare the arrays
// twice to make GCC and LLVM happy about address space casting.  You
// do not need to do this in your normal code because data is not
// assigned to the .dram section in CUDA
float A[N_ELS] __attribute__ ((section (".dram"))) = MACRO_A;
float B[N_ELS] __attribute__ ((section (".dram"))) = MACRO_B;
float C[N_ELS] __attribute__ ((section (".dram"))) = {0};
float gold[N_ELS] __attribute__ ((section (".dram")));

float bsg_attr_remote _A[N_ELS] __attribute__ ((section (".dram"))) = MACRO_A;
float bsg_attr_remote _B[N_ELS] __attribute__ ((section (".dram"))) = MACRO_B;
float bsg_attr_remote _C[N_ELS] __attribute__ ((section (".dram"))) = {0};
float bsg_attr_remote _gold[N_ELS] __attribute__ ((section (".dram"))) = {0};

int main(){

        bsg_set_tile_x_y();

        if ((__bsg_x == 0) && (__bsg_y == 0)) {
                saxpy(A, B, gold, MACRO_ALPHA); 
 
                // **************************************************
                // Test the simple version of SAXPY
                // **************************************************
                bsg_printf("Testing SAXPY\n");
                // Heat the cache (just for demonstration purposes)
                saxpy(A, B, C, MACRO_ALPHA);
                // Measure performance
                bsg_cuda_print_stat_start(SAXPY_TAG_BASE);
                saxpy(A, B, C, MACRO_ALPHA);
                bsg_cuda_print_stat_end(SAXPY_TAG_BASE);
                
                if (memcmp(C, gold, N_ELS * sizeof(*C)))
                        bsg_fail();
                memset(C, 0, N_ELS * sizeof(*C));

                // **************************************************
                // Test the C version of SAXPY
                // **************************************************
                bsg_printf("Testing C SAXPY +unroll\n");
                // Heat the cache (just for demonstration purposes)
                saxpy_c(A, B, C, MACRO_ALPHA);
                // Measure performance
                bsg_cuda_print_stat_start(SAXPY_TAG_C_UNROLL);
                saxpy_c(A, B, C, MACRO_ALPHA);
                bsg_cuda_print_stat_end(SAXPY_TAG_C_UNROLL);
                
                if (memcmp(C, gold, N_ELS * sizeof(*C)))
                        bsg_fail();
                memset(C, 0, N_ELS * sizeof(*C));


                // **************************************************
                // Test the C version of SAXPY, with remote
                // **************************************************
                bsg_printf("Testing C SAXPY +unroll +remote\n");
                // First generate gold values
                saxpy_c_remote(_A, _B, _gold, MACRO_ALPHA);

                // Heat the cache (just for demonstration purposes)
                saxpy_c_remote(_A, _B, _C, MACRO_ALPHA);
                // Measure performance
                bsg_cuda_print_stat_start(SAXPY_TAG_C_UNROLL_REMOTE);
                saxpy_c_remote(_A, _B, _C, MACRO_ALPHA);
                bsg_cuda_print_stat_end(SAXPY_TAG_C_UNROLL_REMOTE);

#ifndef __llvm__
                // LLVM complains about memory intrinsics...
                if (memcmp(_C, _gold, N_ELS * sizeof(*C)))
                        bsg_fail();
                memset(_C, 0, N_ELS * sizeof(*C));
#endif

                // **************************************************
                // Test the C++ version of SAXPY
                // **************************************************
                bsg_printf("Testing C++ SAXPY +unroll\n");
                // Heat the cache (just for demonstration purposes)
                saxpy_cpp(A, B, C, MACRO_ALPHA);
                // Measure performance
                bsg_cuda_print_stat_start(SAXPY_TAG_CPP_UNROLL);
                saxpy_cpp(A, B, C, MACRO_ALPHA);
                bsg_cuda_print_stat_end(SAXPY_TAG_CPP_UNROLL);
                
                if (memcmp(C, gold, N_ELS * sizeof(*C)))
                        bsg_fail();
                memset(C, 0, N_ELS * sizeof(*C));

                // **************************************************
                // Test the C++ version of SAXPY, with remote
                // **************************************************
                bsg_printf("Testing C++ SAXPY +unroll +remote\n");
                // Heat the cache (just for demonstration purposes)
                saxpy_cpp_remote(_A, _B, _C, MACRO_ALPHA);
                // Measure performance
                bsg_cuda_print_stat_start(SAXPY_TAG_CPP_UNROLL_REMOTE);
                saxpy_cpp_remote(_A, _B, _C, MACRO_ALPHA);
                bsg_cuda_print_stat_end(SAXPY_TAG_CPP_UNROLL_REMOTE);

#ifndef __llvm__
                // LLVM complains about memory intrinsics...
                if (memcmp(_C, _gold, N_ELS * sizeof(*C)))
                        bsg_fail();
                memset(_C, 0, N_ELS * sizeof(*C));
#endif

                // Finally, Terminate cleanly
                bsg_finish();
        }

        bsg_wait_while(1);
}
