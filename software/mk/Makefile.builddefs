ifeq ($(RISCV_BIN_DIR),)
$(error RISCV_BIN_DIR not defined)
endif

BSG_MANYCORE_BANKS=4
# in bytes
BSG_MANYCORE_BANKSIZE=2048

#####################################################
# DO we have the FPU implemented ?
ifeq ($(BSG_FPU_OP),1)
ARCH_OP=rv32imafd
else
ARCH_OP=rv32ima
endif
#####################################################

# paths
RISCV_GCC     ?= $(RISCV_BIN_DIR)/riscv32-unknown-elf-gcc
RISCV_ELF2HEX ?= LD_LIBRARY_PATH=$(RISCV_BIN_DIR)/../lib $(RISCV_BIN_DIR)/elf2hex
RISCV_OBJCOPY ?= $(RISCV_BIN_DIR)/riscv32-unknown-elf-objcopy
RISCV_AR      ?= $(RISCV_BIN_DIR)/riscv32-unknown-elf-ar
RISCV_SIM     ?= $(RISCV_BIN_DIR)/spike

BSG_ROM_GEN = $(BSG_IP_CORES_DIR)/bsg_mem/bsg_ascii_to_rom.py
HEX2BIN     = $(BSG_MANYCORE_DIR)/software/py/hex2binascii.py

VPATH += $(BSG_MANYCORE_DIR)/software/spmd/common
VPATH += $(BSG_MANYCORE_DIR)/software/bsg_manycore_lib

# flags
OPT_LEVEL ?= -O0
RISCV_GCC_EXTRA_OPTS ?=
RISCV_GCC_OPTS  =-march=$(ARCH_OP) -static -std=gnu99 -ffast-math -fno-common
RISCV_GCC_OPTS +=$(RISCV_GCC_EXTRA_OPTS) -I$(BSG_MANYCORE_DIR)/software/spmd/common/ -I$(BSG_MANYCORE_DIR)/software/bsg_manycore_lib
RISCV_GCC_OPTS +=-Dbsg_tiles_X=$(bsg_tiles_X) -Dbsg_tiles_Y=$(bsg_tiles_Y)
RISCV_GCC_OPTS +=-Dbsg_global_X=$(bsg_global_X) -Dbsg_global_Y=$(bsg_global_Y)
RISCV_GCC_OPTS +=-Dbsg_group_size=$(bsg_group_size)
ifeq ($(BSG_NEWLIB), 1)
	ARGC ?= 1
	ARGV ?= main

  RISCV_GCC_OPTS +=-D__bsg_newlib
  RISCV_GCC_OPTS +=-D__bsg_argc=$(ARGC)

  comma:=,
  empty:=
  space:=$(empty) $(empty)
  RISCV_GCC_OPTS +=-D__bsg_argv=\"$(subst $(space),\"$(comma)\",$(strip $(ARGV)))\"
endif

SPMD_COMMON_OBJECTS ?=

ifeq ($(BSG_NEWLIB), 1)
SPMD_COMMON_OBJECTS += lfs.o
SPMD_COMMON_OBJECTS += args.o
SPMD_COMMON_OBJECTS += bsg_newlib_intf.o

LFS_BLOCK_SIZE ?= 128
LFS_BLOCK_COUNT ?= 64

lfs.c: $(IN_FILES)
	$(RISCV_BIN_DIR)/../riscv32-unknown-elf/bin/bsg_newlib_mklfs $(LFS_BLOCK_SIZE) $(LFS_BLOCK_COUNT) $(IN_FILES) > $@
endif

# Manycore C library archiving rule
BSG_MANYCORE_LIB_OBJS+= bsg_set_tile_x_y.o
BSG_MANYCORE_LIB_OBJS+= bsg_printf.o

BSG_MANYCORE_LIB = bsg_manycore_lib.a

#RISCV_LINK_EXTRA_OPTS ?=
RISCV_LINK_OPTS ?= 
ifneq ($(BSG_NEWLIB), 1)
  RISCV_LINK_OPTS += -nostdlib
endif
RISCV_LINK_OPTS += -march=$(ARCH_OP) -nostartfiles -ffast-math -lc -lm -lgcc $(RISCV_LINK_EXTRA_OPTS) \
						         -L $(BSG_MANYCORE_DIR)/software/spmd/common


spmd_defs = -DPREALLOCATE=0 -DHOST_DEBUG=0

LINK_SCRIPT ?= $(BSG_MANYCORE_DIR)/software/spmd/common/test.ld 

RISCV_LINK = $(RISCV_GCC) -t -T $(LINK_SCRIPT)\
						 -Wl,--defsym,bsg_group_size=$(bsg_group_size)

ifdef CLANG
export LLVM_DIR   = /mnt/bsg/diskbits/neilryan/llvm/llvm-install
LLVM_CLANG       ?= $(LLVM_DIR)/bin/clang
LLVM_OPT         ?= $(LLVM_DIR)/bin/opt
LLVM_LLC         ?= $(LLVM_DIR)/bin/llc
PASS_DIR         ?= $(BSG_MANYCORE_DIR)/software/manycore-llvm-pass
PASS_LIB         ?= build/manycore/libManycorePass.so
RUNTIME_FNS      ?= $(BSG_MANYCORE_DIR)/software/bsg_manycore_lib/bsg_tilegroup.h

$(LLVM_DIR):
	@echo "LLVM is not installed! Follow build instructions in the TRM and \
	set LLVM_DIR in Makefile.builddefs accordingly" && exit 1

# Remove default %.o: %.c rule
%.o: %.c

# Emit -O0 so that loads to consecutive memory locations aren't combined
# Opt can run optimizations in any order, so it doesn't matter
%.bc: %.c $(PASS_LIB) $(LLVM_DIR) $(RUNTIME_FNS)
	$(LLVM_CLANG) $(RISCV_GCC_OPTS) $(OPT_LEVEL) $(spmd_defs) -c -emit-llvm $(INCS) $< -o $@

%.bc.pass: %.bc
	$(LLVM_OPT) -load $(PASS_LIB) -manycore $(OPT_LEVEL) $< -o $@

%.bc.s: %.bc.pass
	$(LLVM_LLC) $< -o $@

%.o: %.bc.s
	$(RISCV_GCC) $(RISCV_GCC_OPTS) $(OPT_LEVEL) -c $< -o $@


$(PASS_LIB): $(PASS_DIR)/manycore/Manycore.cpp $(LLVM_DIR)
	mkdir -p build
	cd build && cmake $(PASS_DIR) -Dbsg_group_size:INTEGER=$(bsg_group_size) && make

else
%.o: %.c
	$(RISCV_GCC) $(RISCV_GCC_OPTS) $(OPT_LEVEL) $(spmd_defs) -c $(INCS) $< -o $@ |& tee $*.comp.log
endif

%.o: %.S
	$(RISCV_GCC) $(RISCV_GCC_OPTS) $(OPT_LEVEL) $(spmd_defs) -D__ASSEMBLY__=1 \
		-c $(INCS) $< -o $@


$(BSG_MANYCORE_LIB): $(BSG_MANYCORE_LIB_OBJS)
	$(RISCV_AR) rcs $@ $^


# <bytes per row> <rows>
%.hex: %.riscv
	$(RISCV_ELF2HEX) $(BSG_MANYCORE_BANKS) $(BSG_MANYCORE_BANKSIZE) $< > $@

# dump the data memory content
%_dmem.mem:	%.riscv
	$(RISCV_OBJCOPY) -O verilog -j *.dmem $< $@

# dump the dram content
%_dram.mem:	%.riscv
	$(RISCV_OBJCOPY) -O verilog -j *.dram $< $@

	# Load addresses to dram start with 0x8 because NPA of dram start 
	# with 0x8. But verilog loader's readmemh cannot handle large addresses
	# starting with 0x8! Hence this changes load addresses to start with 
	# 0x0, and converting to actual NPA is handled in the verilog loader.
	sed -i 's/@8/@0/' $@

%.bin:  %.hex
	python $(HEX2BIN) $< 32 > $@

%.dis: %.riscv
	$(RISCV_BIN_DIR)/riscv32-unknown-elf-objdump -M numeric --disassemble-all -S $<

%.spike: %.riscv
ifdef DEBUG
	$(RISCV_SIM) -d --isa=$(ARCH_OP) $<
else
	$(RISCV_SIM) -l --isa=$(ARCH_OP) $< 2> spike.log
endif

%.S: %.c
	$(RISCV_GCC) $(RISCV_GCC_OPTS) $(spmd_defs) -S -fverbose-asm $(INCS) $< -o $@ |& tee $*.comp.log

#added the '0x' prefix and and a ',' prefix to each line except the last line.
#can be used to initialize a vector in C launguage.
%.vec.c: %.hex
	sed -e '$$ ! s/.*/0x&,/' $< | sed -e '$$ s/.*/0x&/'	 > $@
	sed -i -e '1i \int manycore_mem_vect [ $(BSG_MANYCORE_BANKSIZE) ] __attribute__ ( (aligned ($(BSG_MANYCORE_BANKSIZE)* $(BSG_MANYCORE_BANKS)) ) ) = {' $@
	sed -i -e '$$a \}  ;' $@
	echo "int  bsg_rocc_manycore_mem_words=2048; "  >> $@

%.riscv64:	%.riscv
	$(RISCV_BIN_DIR)/riscv32-unknown-elf-objcopy --output-target=elf64-littleriscv  $< $@

%.cfg.h:    %.riscv
	sed -n 's/^.*MANYCORE_EXPORT//p' *.comp.log > $@
