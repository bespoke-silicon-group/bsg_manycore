ifeq ($(RISCV_BIN_DIR),)
$(error RISCV_BIN_DIR not defined)
endif

BSG_MANYCORE_BANKS=4
# in bytes
BSG_MANYCORE_BANKSIZE=2048

#####################################################
# DO we have the FPU implemented ?
ifeq ($(BSG_FPU_OP),1)
ARCH_OP=rv32imafd
else
ARCH_OP=rv32ima
endif
#####################################################

# paths
RISCV_GCC     ?= $(RISCV_BIN_DIR)/riscv32-unknown-elf-gcc
RISCV_ELF2HEX ?= LD_LIBRARY_PATH=$(RISCV_BIN_DIR)/../lib $(RISCV_BIN_DIR)/elf2hex
RISCV_OBJCOPY ?= $(RISCV_BIN_DIR)/riscv32-unknown-elf-objcopy

BSG_ROM_GEN = $(BSG_IP_CORES_DIR)/bsg_mem/bsg_ascii_to_rom.py
HEX2BIN     = $(BSG_MANYCORE_DIR)/software/py/hex2binascii.py

VPATH += $(BSG_MANYCORE_DIR)/software/bsg_manycore_lib

# flags
RISCV_GCC_EXTRA_OPTS ?= -O2
RISCV_GCC_OPTS  = -march=$(ARCH_OP) -static -std=gnu99 -ffast-math -fno-common -fno-builtin-printf $(RISCV_GCC_EXTRA_OPTS) -I$(BSG_MANYCORE_DIR)/software/spmd/common/ -I$(BSG_MANYCORE_DIR)/software/bsg_manycore_lib -Dbsg_tiles_X=$(bsg_tiles_X) -Dbsg_tiles_Y=$(bsg_tiles_Y)

#RISCV_LINK_EXTRA_OPTS ?=
RISCV_LINK_OPTS = -march=$(ARCH_OP) -nostdlib -nostartfiles -ffast-math -lc -lgcc -L $(BSG_MANYCORE_DIR)/software/spmd/common $(RISCV_LINK_EXTRA_OPTS)
spmd_defs = -DPREALLOCATE=0 -DHOST_DEBUG=0

RISCV_LINK = $(RISCV_GCC) -T $(BSG_MANYCORE_DIR)/software/spmd/common/test.ld

ifdef CLANG
LLVM_DIR       = /mnt/bsg/diskbits/neilryan/llvm/llvm-install
LLVM_CLANG    ?= $(LLVM_DIR)/bin/clang
LLVM_OPT      ?= $(LLVM_DIR)/bin/opt
LLVM_LLC      ?= $(LLVM_DIR)/bin/llc
PASS_FILE = libManycorePass.so
PASS_DIR = $(BSG_MANYCORE_DIR)/software/manycore-llvm-pass
PASS_LIB = build/manycore/$(PASS_FILE)

%.o: %.c $(PASS_LIB)
	$(LLVM_CLANG) $(RISCV_GCC_OPTS) $(spmd_defs) -c -emit-llvm $(INCS) $< -o $*.bc
	$(LLVM_OPT) -load $(PASS_LIB) -manycore $*.bc -o $*.bc.pass
	$(LLVM_LLC) $*.bc.pass -o $*.s
	$(RISCV_GCC) $(RISCV_GCC_OPTS) -c $*.s -o $@
	rm -f $*.s $*.bc $*.bc.pass

$(PASS_LIB): $(PASS_DIR)/manycore/Manycore.cpp
	mkdir -p build && cd build && cmake $(PASS_DIR) && make
else
%.o: %.c
	$(RISCV_GCC) $(RISCV_GCC_OPTS) $(spmd_defs) -c $(INCS) $< -o $@ |& tee $*.comp.log
endif


%.o: %.S
	$(RISCV_GCC) $(RISCV_GCC_OPTS) $(spmd_defs) -D__ASSEMBLY__=1 \
		-c $(INCS) $< -o $@

# <bytes per row> <rows>
%.hex: %.riscv
	$(RISCV_ELF2HEX) $(BSG_MANYCORE_BANKS) $(BSG_MANYCORE_BANKSIZE) $< > $@

# dump the data memory content
%_dmem.mem:	%.riscv
	$(RISCV_OBJCOPY) -O verilog -R .text $< $@

# dump the dram content
%_dram.mem:	%.riscv
	$(RISCV_OBJCOPY) -O verilog -j .text $< $@
	#  The objcopy program will dump the sections with @[pysical address] notation, which tells
	#  the verilog loader where to place the data.
	#   
	#  Ideally the physicall address should be 0x8000_0000, which is the DRAM address used in manycore 
	#  program, but the system verilog $readmemh() just can not read from such large address... 
	#  
	#  Instead we just use a faked physical address and assumpt the phyiscal address is aslo zero in the loader, 
	#  And so we delete the first line of the dump files which is faked physical address...
	sed -i -e "1d" $@

%.bin:  %.hex
	python $(HEX2BIN) $< 32 > $@

%.dis: %.riscv
	$(RISCV_BIN_DIR)/riscv32-unknown-elf-objdump -M numeric --disassemble-all $<

#added the '0x' prefix and and a ',' prefix to each line except the last line.
#can be used to initialize a vector in C launguage.
%.vec.c: %.hex
	sed -e '$$ ! s/.*/0x&,/' $< | sed -e '$$ s/.*/0x&/'	 > $@
	sed -i -e '1i \int manycore_mem_vect [ $(BSG_MANYCORE_BANKSIZE) ] __attribute__ ( (aligned ($(BSG_MANYCORE_BANKSIZE)* $(BSG_MANYCORE_BANKS)) ) ) = {' $@
	sed -i -e '$$a \}  ;' $@
	echo "int  bsg_rocc_manycore_mem_words=2048; "  >> $@

%.riscv64:	%.riscv
	$(RISCV_BIN_DIR)/riscv32-unknown-elf-objcopy --output-target=elf64-littleriscv  $< $@

%.cfg.h:    %.riscv
	sed -n 's/^.*MANYCORE_EXPORT//p' *.comp.log > $@
